# Implementation Plan: Database Admin CLI

**Branch**: `001-db-admin-cli` | **Date**: 2025-10-25 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-db-admin-cli/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Add CLI commands to the existing WTT application executable to enable database administration tasks without starting the server. Administrators will be able to change admin user credentials (email/password) and export the database for backups. The CLI will be integrated into the same single-file executable (`src/server.ts`) and must preserve the current default behavior (starting the server when run with no arguments).

## Technical Context

**Language/Version**: TypeScript 5.8.3 with Bun 1.x runtime
**Primary Dependencies**:
- better-auth 1.2.10 (authentication/password hashing)
- better-sqlite3 12.0.0 (database operations)
- Zod 4.1.12 (validation)
- Bun standard library (CLI argument parsing, file I/O, console I/O)

**Storage**: SQLite database (existing at path from DB_FILE config)
**Testing**: Bun test (unit, integration, contract tests following test-first approach)
**Target Platform**: Linux/macOS/Windows servers where Bun runtime is supported
**Project Type**: Single web application (WTT)
**Performance Goals**:
- Credential changes complete in <30 seconds
- Database exports for 1GB databases complete in <5 minutes
- CLI startup/parsing overhead <100ms

**Constraints**:
- Must integrate into existing src/server.ts entrypoint
- Must not start web servers when in CLI mode
- Must preserve default server-start behavior when run with no arguments
- All database operations must be synchronous/blocking
- Must work offline without network access
- Must handle database file locking gracefully

**Scale/Scope**:
- 3 CLI commands (change-email, change-password, export-db)
- 1 modified entrypoint file (src/server.ts)
- ~200-300 LOC for CLI implementation
- Small user base (system administrators only)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify adherence to core principles from `.specify/memory/constitution.md`:

- [x] **I. Type Safety & Validation**: Plan includes Zod schemas for CLI input validation (email format, password requirements, file paths)
- [x] **II. Server-Only Boundaries**: All CLI code will be server-only (marked with `import "@/server-only";`)
- [x] **III. Feature-Based Organization**: CLI admin feature organized in `src/cli-admin/` directory
- [x] **IV. One Concept Per File**: Separate files for: argument parsing, email change, password change, database export, help text
- [x] **V. Test-First Development**: Contract tests for CLI interface, integration tests for database operations, unit tests for validation
- [x] **VI. AI Developer Anchors**: Complex areas identified: CLI mode detection logic, password hashing integration, database file locking
- [x] **VII. Simplicity & YAGNI**: Using Bun's built-in `process.argv` parsing (no external CLI library), simple command pattern

*All checks pass. No violations to justify.*

## Project Structure

### Documentation (this feature)

```text
specs/001-db-admin-cli/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output (CLI contract definitions)
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── cli-admin/           # NEW: CLI admin feature area
│   ├── index.ts        # CLI entrypoint & command router
│   ├── change-email.ts # Email change command implementation
│   ├── change-password.ts # Password change command implementation
│   ├── export-db.ts    # Database export command implementation
│   ├── validation.ts   # Zod schemas for CLI inputs
│   ├── help.ts         # Help text generation
│   └── io.ts           # Console I/O utilities (password masking, prompts)
├── server.ts           # MODIFIED: Add CLI mode detection before server start
├── auth/               # EXISTING: Will use for password hashing
├── db/                 # EXISTING: Will use for database access
├── config.ts           # EXISTING: Will use for DB_FILE path
└── util/               # EXISTING: May add CLI utilities if cross-cutting

tests/
├── contract/
│   └── cli-admin.test.ts     # NEW: CLI command contracts
├── integration/
│   └── cli-admin.test.ts     # NEW: Database operation integration tests
└── unit/
    └── cli-admin/            # NEW: Unit tests for validation, I/O, etc.
        ├── validation.test.ts
        ├── io.test.ts
        └── help.test.ts
```

**Structure Decision**: Using WTT's existing single-project structure with feature-based organization (Constitution Principle III). The new `src/cli-admin/` directory contains all CLI administration functionality, keeping it separate from the existing server/webhook/dashboard features. The entrypoint (`src/server.ts`) will be modified to detect CLI mode and route to `src/cli-admin/index.ts` before starting servers.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

*No violations. All constitution principles are satisfied.*

## Phase 0: Research & Design Decisions

### Research Questions

1. **CLI Argument Parsing**: How to parse arguments using Bun's built-in capabilities without external libraries?
2. **Password Hashing Integration**: How does better-auth hash passwords, and how can we reuse that logic?
3. **Admin User Identification**: How is the admin user identified in the database (role, flag, or specific record)?
4. **Database File Locking**: How to detect and handle SQLite database file locks?
5. **Password Masking**: How to mask password input in terminal using Bun APIs?
6. **File Copy for Export**: Best practice for copying SQLite database files (simple copy vs. backup API)?

### Technology Decisions

- **CLI Framework**: None (using Bun's `process.argv` directly for simplicity)
- **Argument Pattern**: Command-based (e.g., `bun run src/server.ts change-email new@example.com`)
- **Password Hashing**: Reuse better-auth's existing password hashing utilities
- **Database Export Method**: SQLite VACUUM INTO or simple file copy
- **Input Validation**: Zod schemas for all CLI inputs
- **Error Handling**: Try-catch with clear error messages, exit codes (0=success, 1=error)

See [research.md](./research.md) for detailed findings.

## Phase 1: Design Artifacts

### Data Model

See [data-model.md](./data-model.md) for:
- Admin user entity structure (from existing database schema)
- CLI command input/output structures
- Validation rules for email, password, file paths

### API Contracts

See [contracts/](./contracts/) for:
- CLI command interface contracts (arguments, outputs, exit codes)
- Database operation contracts (queries, updates)
- Error response formats

### Quick Start Guide

See [quickstart.md](./quickstart.md) for:
- How to use each CLI command
- Example command invocations
- Troubleshooting common issues

## Phase 2: Task Breakdown

*Generated by `/speckit.tasks` command - not part of this plan.*

See [tasks.md](./tasks.md) when ready to implement.

## Implementation Notes

### CLI Mode Detection Strategy

The `src/server.ts` entrypoint will check `process.argv` at startup:

1. If `argv.length <= 2` (no arguments) → Start server normally (default behavior)
2. If `argv[2]` is a recognized CLI command → Route to CLI handler, exit when done
3. If `argv[2]` is unrecognized → Show help and exit with error

This preserves backward compatibility while adding CLI functionality.

### Command-Line Interface Design

```bash
# Default behavior (no arguments) - starts server
bun run src/server.ts

# CLI commands (new)
bun run src/server.ts change-email <new-email>
bun run src/server.ts change-password
bun run src/server.ts export-db [output-path]
bun run src/server.ts --help
```

### Integration Points

1. **Auth Integration**: Import password hashing utilities from `src/auth/`
2. **Database Integration**: Use existing database connection from `src/db/`
3. **Config Integration**: Read `DB_FILE` from `src/config.ts`

### Testing Strategy

1. **Contract Tests**: Define expected CLI behavior (inputs → outputs → exit codes)
2. **Integration Tests**: Test against real test database, verify actual changes
3. **Unit Tests**: Test validation logic, I/O utilities, help text generation

All tests follow test-first development (write tests before implementation).

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Breaking default server-start behavior | High | Comprehensive integration tests for both modes |
| Database corruption during export | High | Use SQLite VACUUM INTO or file copy with integrity checks |
| Password hashing incompatibility | Medium | Use exact same better-auth utilities, test with existing auth flow |
| CLI argument parsing ambiguity | Medium | Clear command naming, comprehensive help text, validation |
| Insufficient file permissions | Low | Detect and report with actionable error messages |

## Dependencies on Other Work

- **001-user-management**: Depends on existing admin user database schema and better-auth setup
- **Database migrations**: Must work with current database schema, cannot require migrations

## Success Metrics

From spec.md Success Criteria section:

- **SC-001**: Credential changes complete in <30 seconds ✓ (simple DB update)
- **SC-002**: Export 1GB DB in <5 minutes ✓ (file copy ~200MB/s typical)
- **SC-003**: 100% password hashing ✓ (enforced by using better-auth utilities)
- **SC-004**: Actionable error messages ✓ (explicit validation messages, examples in help)
- **SC-005**: Zero plaintext passwords ✓ (better-auth hashing, validation tests)
- **SC-006**: 99% success rate ✓ (comprehensive error handling, input validation)

## Next Steps

1. Run `/speckit.plan` Phase 0 to generate `research.md` (research questions above)
2. Run `/speckit.plan` Phase 1 to generate design artifacts (data-model, contracts, quickstart)
3. Run `/speckit.tasks` to generate implementation tasks
4. Begin test-first implementation following task order
